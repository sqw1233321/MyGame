// Copyright (c) 2017-2020 Xiamen Yaji Software Co., Ltd.
CCEffect %{
techniques:
  - passes:
      - vert: sprite-vs:vert
        frag: sprite-fs:frag
        depthStencilState:
          depthTest: false
          depthWrite: false
        blendState:
          targets:
            - blend: true
              blendSrc: src_alpha
              blendDst: one_minus_src_alpha
              blendDstAlpha: one_minus_src_alpha
        rasterizerState:
          cullMode: none
        properties:
          alphaThreshold: { value: 0.1 }
          outlineColor: { value: [0.0, 1.0, 0.0, 1.0] } #0~1
          outlineWidth: { value: 0.0 }
          aplhaThrold: { value: 0.0 }
          u_scale: { value: 1.05 }

}%

CCProgram sprite-vs %{
precision highp float;
#include <cc-global>
#include <cc-local>
#if SAMPLE_FROM_RT
  #include <common>
#endif
in vec3 a_position;
in vec2 a_texCoord;
in vec4 a_color;

out vec4 color;
out vec2 uv0;

uniform Constants0 {
  float u_scale;
};

vec4 vert() {
  vec4 pos = vec4(a_position, 1);
  
  #if USE_LOCAL
    pos = cc_matWorld * pos;
  #endif
  
  vec3 center = (cc_matWorld * vec4(0, 0, 0, 1)).xyz;
  vec3 dir = normalize(pos.xyz - center);
  pos.xyz += dir * u_scale;
  
  #if USE_PIXEL_ALIGNMENT
    pos = cc_matView * pos;
    pos.xyz = floor(pos.xyz);
    pos = cc_matProj * pos;
  #else
    pos = cc_matViewProj * pos;
  #endif
  
  uv0 = a_texCoord;
  #if SAMPLE_FROM_RT
    CC_HANDLE_RT_SAMPLE_FLIP(uv0);
  #endif
  color = a_color;
  
  return pos;
}
}%

CCProgram sprite-fs %{
precision highp float;
#include <embedded-alpha>
#include <alpha-test>

uniform Constants1 {
  vec4 outlineColor;
  float outlineWidth;
  float aplhaThrold;
};

in vec4 color;

#if USE_TEXTURE
  in vec2 uv0;
  #pragma builtin(local)
  layout(set = 2, binding = 11)uniform sampler2D cc_spriteTexture;
#endif

vec4 frag() {
  vec4 o = vec4(1, 1, 1, 1);
  
  #if USE_TEXTURE
    o *= CCSampleWithAlphaSeparated(cc_spriteTexture, uv0);
    float originalAlpha = o.a;
    if (originalAlpha < aplhaThrold) {
      float outlineAlpha = 0.0;
      float pixelWidth = outlineWidth / 52.0;
      vec2 offset = vec2(pixelWidth, pixelWidth);
      for(int x = -1; x <= 1; x ++ ) {
        for(int y = -1; y <= 1; y ++ ) {
          if (x == 0 && y == 0)continue;
          vec2 sampleUV = uv0 + vec2(x, y) * offset;
          float a = texture(cc_spriteTexture, sampleUV).a;
          outlineAlpha = max(outlineAlpha, a);
        }
      }
      if (outlineAlpha >= aplhaThrold) {
        float borderAlpha = smoothstep(0.05, 0.15, outlineAlpha);
        vec4 border = outlineColor;
        border.a *= borderAlpha;
        o = border;
      }
    }
    #if IS_GRAY
      float gray = 0.2126 * o.r + 0.7152 * o.g + 0.0722 * o.b;
      o.r = o.g = o.b = gray;
    #endif
  #endif
  
  o *= color;
  ALPHA_TEST(o);
  return o;
}
}%
